<h2>【DB概論】DBMSに求められるもの（2）耐障害性</h2>

<p>　障害発生に対して、DBMSは最大限の回復措置を提供しています。しかし、障害を回復する手順をすべて自動で行うわけにはいきません。いざ障害が起きたときに正しい手順を落ち着いて遂行するために、次の事柄を明確にしておく必要があります。</p>
<ul>
<li>障害時に要求されるユーザー要件（回復にかけることのできる時間など）</li>
<li>データベースに対する更新処理の種類</li>
<li>回復時に実行される手順</li>
<li>データベースの運用要件</li>
<li>データベースのハードウェア要件</li>
<li>どのような障害に対応する必要があるのか</li>
<li>障害対策例</li>
<li>バックアップの種類</li>
</ul>
<h4>障害時に要求されるユーザー要件</h4>
<p>　ユーザー要件として確かめておくべき要件は、次の2つです。障害の種類ごとにこの2点を確認しておく必要があります。</p>
<ul>
<li>MTTR（Mean Time To Repair：平均回復時間）</li>
<li>MTBF（Mean Time Between Failure：平均障害間隔）</li>
</ul>
<p>　一般的に起き得る障害のうち物理ディスク障害の場合を考えてみます。</p>
<p><strong>●MTTR（Mean Time To Repair：平均回復時間）</strong></p>
<p>　平均回復時間は、おおまかにいって下記の時間を足した時間になります。</p>
<div class="trBoxC"><div class="trBoxWidth" style="width:590px;">
<div class="box cmsBoxNoborder cmsBox">
<p>障害が起きた後バックアップを戻す時間</p>
<p>＋</p>
<p>バックアップファイルを取得した時刻以降、データベースに適用された変更すべてをバックアップファイルに適用する時間</p>
<p>＋</p>
<p>更新ログのうち、COMMITが完了していない仕掛中の更新をロールバックする時間</p>
<br clear="all"><span></span></div>
</div></div>
<p>　バックアップを戻す時間を短くするためには、障害が起きる可能性のあるファイルのサイズを小さくする必要があります。 データベースの物理ファイルの1つ1つを小さく設計しておけば、障害時にバックアップファイルを戻す時間を短くすることができます。</p>
<p>　変更をバックアップファイルに適用する時間を短くするためには、バックアップを頻繁に取得して、バックアップ以降に取得した更新ログを少なくする必要があります。 そのため、頻繁に更新される表を格納している可能性のあるファイルは、頻繁にバックアップをとる必要があります。</p>
<p>　逆に、ほとんど更新されないファイルはあまりバックアップをとる必要はないため、バックアップ対象から外せばバックアップを取得する時間を短縮することができます。 読み取り専用データを格納している表のみを含むファイルは、一度バックアップをとれば、その後バックアップをとる必要はありません。</p>
<p><strong>●MTBF（Mean Time Between Failure：平均障害間隔）</strong></p>
<p>　平均障害間隔は、ユーザーによっては限りなく無限大を要求される場合もあります。 このような場合には、ハードウェア的な障害対策（ディスクの全二重化、すべてのコンポーネントの二重化）も検討する必要があります。 これらの要件は、システム構成全体を設計する<strong>方式設計</strong>と呼ばれる工程で検討する必要があります。</p>
<p>　次に、障害発生時の回復処理を確実にするために、DBMSは「更新処理から更新確定処理まで」をどのような仕組みで処理しているかを説明します。 ここでは、Oracleデータベースを例にポイントを解説します。</p>
<h4>データベースに対する更新処理（COMMIT時の処理フロー）</h4>
<p>　図1は、Oracleデータベースのメモリ上のコンポーネントと物理的なディスク上のコンポーネントの概要を示しています。</p>
<p>　上半分の四角の枠内がメモリ上のコンポーネントで、下半分が物理的なファイル群です。</p>
<!--CAP-->
<div id="col500"><a name="r503-02.gif"></a><img src="./images/r503-02.gif" width="460" height="323" alt="図1 更新処理">
<small><strong>図1 更新処理</strong></small></div>
<!--CAPEND-->
<p><strong>1．</strong>トランザクションが開始されます。</p>
<p><strong>2．</strong>更新に必要なブロックが、データファイルからメモリ上のDBバッファキャッシュに読み込まれます。</p>
<p>　ブロックの種類は、直接更新する必要のある表、または索引のブロックと、トランザクションの更新を元に戻すために必要な情報（以降、更新前情報）を格納するためのロールバックブロックの2種類があります。</p>
<p>　表や索引のブロックに関しては、そのトランザクション内で更新すべき行が含まれているすべてのブロックが読み込まれます。 一方、ロールバックブロックは、トランザクション単位で管理され、更新前情報を順次書き込んでいきます。 ロールバックセグメントヘの書き込みは、1トランザクション単位で1つの塊になります。</p>
<p><strong>3．</strong>更新対象の行にロックをかけた後、REDOログバッファにREDOログレコードを書き込みます。 変更処理では、どのブロックに対してどのような更新処理が行われるかという情報を、REDOログレコードという形で、まずREDOログバッファに書き込みます。</p>
<p>　表のブロックに対しては、更新後の情報をREDOログレコードとして作成し、REDOログバッファに書き込みます。</p>
<p>　 ロールバックブロックに対する変更は、変更処理ごとに更新前情報をREDOログバッファに書き込んでいきます。 このとき、同じ変更処理（例えばUPDATE文）で作成された更新前情報と更新後の情報は1対にして書き込まれていきます。</p>
<p>　REDOログレコードは、処理された順番を確認するため、データベース内で一意な番号<strong>SCN（System Commitment Number）</strong>番号をもっています。</p>
<p><strong>4．</strong>REDOログバッファに書き込まれた内容を用いて、DBバッファキャッシュ上の該当ブロックが更新されます。 更新される対象となるブロックは、表または索引のブロックとロールバックブロックです。 トランザクションが継続している間、更新処理の数分だけ、2.から4.までの処理が必要に応じて繰り返し実行されます。 ロールバックセグメントには、更新を元に戻すための情報が、トランザクション開始からトランザクションの最後の更新まで順番に格納されます。</p>
<p><strong>5．</strong>COMMIT文が発行されると、REDOログバッファに格納されていたREDOログレコードがREDOログファイルに書き込まれ、更新情報が物理的なファイルに書き込まれることを保証します。</p>
<p><strong>6．</strong>REDOログファイルは、同じ大きさのログファイルを複数作成しておき、それにグループ番号を付与して順番に循環して書き込みができるようにします。 また、REDOログファイルは物理ファイルですから、サイズの上限があります。</p>
<p>　一時点で書き込みができるグループは1つですから、そのグループヘの書き込みがいっぱいになると、<strong>ログスイッチ</strong>というイベントが発生し、書き込み先が次のグループに切り替わります。 REDOログファイルに書き込まれた内容は、障害回復時に必要な情報なので、書き込みが循環して再度そのファイルを上書きしてしまう前に、<strong>アーカイブログファイル</strong>にコピーします。</p>
<p>　 ただし、アーカイブログファイルにコピーするという動きは、Oracleデータベースの運用モードがARCHIVELOGモードで運用されている場合のみです。</p>

<h4>回復時に実行される手順</h4>
<p>　データベースの設計を行う際に、どのようなタイミングでどのファイルのバックアップをとるべきか、バックアップファイルの種類としてどのようなファイルを取得するべきかを考慮した運用手順を設計する必要があります。 まず、回復に必要なファイルを図2で確認しましょう。</p>
<!--CAP-->
<div id="col500"><a name="r503-03.gif"></a><img src="./images/r503-03.gif" width="453" height="298" alt="図2 回復処理フロー">
<small><strong>図2 回復処理フロー</strong></small></div>
<!--CAPEND-->
<p><strong>●データベースのバックアップファイル</strong></p>
<p>　ディスクに物理的な障害が起きた場合、ディスクを交換し、直近に取得したバックアップファイルを戻して回復処理を行います。 そこで必要になるのが、物理的なファイルのコピーによって作成されたバックアップファイルです。 Oracleデータベースの場合、図2の左側にある、制御ファイル、データファイル、REDOログファイルの3種類のファイルのバックアップを取得します。</p>
<p>　バックアップの種類も、「<strong>オンラインバックアップ</strong>」と「<strong>オフラインバックアップ</strong>」の2種類があります。 運用上データベースをシャットダウンできるのであれば、定期的にオフラインバックアップをとります。 データベースの全ファイルのオフラインバックアップを取得しておくと、最悪の場合でも、そのファイルを戻すことによってシャットダウン時のデータベースの状態に戻すことができます。</p>
<p>　しかし、システムを停止することができないような場合（365日24時間フル稼働の場合）もあります。 この場合は、オンラインバックアップを取得します。</p>
<p>　REDOログファイルは、オンラインバックアップの場合には取得しません。 REDOログファイルは、データベース内で起きたすべての更新処理をREDOログレコードという形で格納しているファイルです。</p>
<p>　また、REDOログファイルは複数のグループで構成されていて、グループのファイルがいっぱいになると、次のグループに書き込みを継続できるようになっています（図の中ではグループ1→グループ2→グループ3）。 このグループ切替のタイミングを<strong>ログスイッチ</strong>と呼びます。 ログスイッチのタイミングで、アーカイブ処理とチェックポイント処理が後続で実行されます。</p>
<!--CAP-->
<div id="col500"><a name="r503-04.gif"></a><img src="./images/r503-04.gif" width="448" height="281" alt="図3 バックアップ処理">
<small><strong>図3 バックアップ処理</strong></small></div>
<!--CAPEND-->
<ul>
<li><strong>アーカイブ処理</strong></li>
</ul>
<p>　<strong>アーカイブ処理</strong>は、REDOログファイルをアーカイブファイルにコピーする処理です。 REDOログをアーカイブファイルにコピーすることによって、REDOログファイルが循環利用されて上書きされても、更新ログが残るようになっています。 アーカイブファイルにもログ順序番号が割り振られ、障害時に適用する順番がわかるようになっています。</p>
<ul>
<li><strong>チェックポイント</strong></li>
</ul>
<p>　<strong>チェックポイント</strong>というイベントは、それまでにメモリ上で更新されたブロックを、データファイルに書き込むことによって、定期的にメモリ上の更新状態とディスク上のデータファイルの同期をとる処理です。</p>
<p>　同期をとったデータファイルのヘッダには、同期をとった時刻、データベース内で使用しているSCN番号を記し、ここまでの更新ブロックがデータファイルに反映されていることを示します。</p>
<p>　ディスク障害などが起きて、バックアップファイルを戻した場合には、このチェックポイントが完了した時点（SCN番号）を確認して、そこから回復処理を始めることができます。 また、チェックポイントの情報は制御ファイルやREDOログファイルにも記されていて、障害回復のために必要な情報として使用されます。</p>
<p><strong>●トランザクションの回復手順</strong></p>
<p>　障害発生時の具体的な回復手順について説明します。 トランザクションがCOMMITされた場合、障害が起きてもそのトランザクションは回復でき、COMMITされていないトランザクションは、ロールバックしてデータベース内の整合性を維持する必要があると説明しました。 その仕組みについて、図4を使って説明します</p>
<!--CAP-->
<div id="col500"><a name="r503-05.gif"></a><img src="./images/r503-05.gif" width="457" height="387" alt="図4 回復処理フロー">
<small><strong>図4 回復処理フロー</strong></small></div>
<!--CAPEND-->
<p>　1段目には、トランザクションの区切りとメモリ上の変更を示しています。 トランザクション1とトランザクション2はCOMMITしましたが、トランザクション3の仕掛途中にメモリ障害が発生したという想定です。</p>
<p>　2段目はデータベースの状態を示しています。 データベースとは、ここでは物理的なファイル上の状態を表します。 メモリ上にはすべての変更が記述されていますが、データベースには変更がリアルタイムで反映されるわけではありません。</p>
<p>　変更が反映されるイベントの1つとしてチェックポイントがあります。 ここでは、トランザクション1がCOMMITした後にチェックポイントが発生したという想定です。 チェックポイントが完了したときのSCN番号は1500で、データベースの各データファイルのヘッダには、チェックポイント完了時のSCN番号1500が記述されています。 チェックポイントによってトランザクション1の変更はデータベースに反映されていますが、トランザクション2、3による変更は、データベースには反映されていません。</p>
<p>　3段目、4段目はREDOログファイルに記述されている更新後の情報を格納するログと更新前情報を時系列に表したものです。 REDOログファイルに書き込みが行われるタイミングはいくつかありますが、任意のトランザクションがCOMMITすると、必ずメモリ上にあった更新ログはREDOログファイルに書き込まれます。</p>
<p>　わかりやすくするために更新前と更新後の記述を分けていますが、実際には処理の順に更新前情報、更新後情報はひとまとまりに格納されます。 処理の順がわかるようにするために、更新ログにはSCN番号が割り振られています。 また、更新前情報と更新後情報を破線で囲んでいますが、これは、ある1つの更新処理によって同時に行われるデータベース内の処理をひとまとまりにしたもので、<strong>チェンジベクタ</strong>とよばれる単位です。</p>
<p>　障害回復処理が行われる場合は、このチェンジベクタ単位の処理が必ず同期をとって実行されます。 つまり、回復処理を行う場合、更新後は表などのデータを含むブロックをSCNの順に更新、また、更新前情報を使って同時にロールバック用のブロックを更新していきます。 これが、一番下の段に記述されている<strong>ロールフォワード</strong>と呼ばれる処理です。</p>
<p><strong>●トランザクションレベルでみた回復の手順</strong></p>
<p>　4段目を見てください。 メモリが消滅してしまったような障害の場合、最後に確実にディスク上に更新が反映されたチェックポイントから回復の手順が始まります。</p>
<ol>
<li><strong>チェックポイントから回復の手順開始：</strong> 最後に起きたチェックポイントの情報は、時系列の情報SCNとともに、制御ファイル、データファイルのヘッダ、REDOログファイルに記されています。 ここから適用すべきREDOログファイルを判別し、ロールフォワード処理が実行されます。</li>
<li><strong>ロールフォワード：</strong> ロールフォワード処理では、チェックポイント以降のデータブロックに対して再度REDOログを適用して更新処理をやり直します。 前述したとおり、更新後のデータブロックには更新後のログを適用し、ロールバック用のブロックには更新前情報を適用していきます。</li>
<li><strong>ロールバック：</strong> REDOログをすべて適用し終えたら、COMMITしていないトランザクションを調べて、ロールバック処理を行います。 2.でロールバック情報も、ロールバックセグメント内のブロックに対して再作成されているので、これを使って時系列を逆に遡って処理していきます。 ロールバック情報はトランザクション単位に管理されていて、逆方向にポインタをたどっていけるようになっています。</li>
<li>トランザクションがCOMMITされた状態またはロールバックされた状態になり、データベースとして整合性のとれた状態になった時点で、障害回復作業は完了します。</li>
</ol>
<p>　複数のトランザクションが同時に進行している場合、障害回復処理がどのように実行されるかを、確認してみます。</p>
<!--CAP-->
<div id="col500"><a name="r503-06.gif"></a><img src="./images/r503-06.gif" width="452" height="362" alt="図5 回復フロー">
<small><strong>図5 回復フロー</strong></small></div>
<!--CAPEND-->
<p>　1番上の段は、メモリ上の処理を示しています。 途中でチェックポイントが実行されています。</p>
<p>　2番目の段は、データベースの「物理的なデータファイル内の、あるブロック内の値」を示しています。 チェックポイントが起きた時点で、メモリ上の変更はデータベースに反映されています。</p>
<p>　3～5番目の段は、3つのトランザクションの処理が実行されていることを示しています。 トランザクション1と2はチェックポイントの前から処理は実行されており、トランザクション1と3は、障害が起きる前にCOMMITが完了していることに注目してください。 このような状況で、障害が発生したとします。障害回復の開始点は、チェックポイントが起きた時です。 トランザクション1と3はCOMMITされていたため、完了状態まで回復されます。トランザクション2は仕掛中だったため、ロールバックされて、何も実行されなかった状態に戻される必要があります。</p>
<p>　6番目の段は、回復した後のデータベースの状況を表しています。</p>
<p><strong>●ディスク障害からの回復</strong></p>
<!--CAP-->
<div id="col500"><a name="r503-07.gif"></a><img src="./images/r503-07.gif" width="459" height="298" alt="図6 ディスク障害からの回復">
<small><strong>図6 ディスク障害からの回復</strong></small></div>
<!--CAPEND-->
<p>　メディア障害から回復するためには、図6に示すように物理バックアップ、REDOログファイル、アーカイブログファイルの3つのファイルが揃っている必要があります。</p>
<p>　障害回復処理は、大きく分けると次の3つの工程になります。</p>
<ol>
<li>障害が起きたファイルをオフラインにし、バックアップファイルをリストア</li>
<li>バックアップファイルに記されているチェックポイント番号から後の更新ログを格納しているアーカイブログファイルを順次適用</li>
<li>アーカイブされていない更新ログを含むREDOログファイルを適用し、COMMITされていなかったトランザクションをロールバック</li>
</ol>
<p>　回復処理時間を短くするためには、次のことに留意します。</p>
<ul>
<li>リストア時間を短くするために、バックアップの単位になっている、物理的なパックアップファイルのサイズを大きくしすぎない</li>
<li>アーカイブログファイルの適用時間を短縮するために、頻繁に更新されるデータファイルは頻繁にバックアップを取得し、適用すべきアーカイブログファイルが少なくてすむようにする</li>
</ul>
<p>　回復に必要な手順は、バックアップの取得方法によって大きく異なります。 バックアップ／リカバリ用の専用ツールを使う場合、上記の説明は当てはまりませんが、基本的な考え方は同じでしょう。</p>
<p>　データベース設計の中で物理設計をする際、障害回復の手順を明らかにしておくことによって、回復処理をなるべく簡潔に、早く終了させることができると考えられます。 障害時に最も危険なのが、オペレータの誤処理による二次災害です。 データベースの内部構造をしっかり理解しておくことによって、落ち着いた処理ができるように心がけておいてください。</p>

<h4>データベースの運用要件</h4>
<p>　データベースの運用要件として、次の点を確認しておく必要があります。</p>
<ul>
<li>ARCHIVELOGモードによる運用かNOARCHIVELOGモードによる運用か</li>
<li>計画的シャットダウンが許容されているか</li>
<li>障害発生時の運用体制</li>
</ul>
<div class="trBoxC"><div class="trBoxWidth" style="width:590px;">
<div class="box cmsBoxNoborder cmsBox">
<p>ARCHIVELOGモード、NOARCHIVELOGモードの設定はOracleデータベースに固有の設定です。</p>
<p>通常のデータベースでは、ARCHIVELOGモードで運用しますが、次のような条件が揃っている場合には、NOARCHIVELOGモードで運用することもあります。</p>
<ul>
<li>毎日データベースをシャットダウンして、全体バックアップを取得できる</li>
<li>1日の更新処理で、REDOログのグループが上書きされない</li>
</ul>
<br clear="all"><span></span></div>
</div></div>
<p>　この運用では、1日の処理中にデータベースの物理障害が起きた場合、前日に取得したバックアップをリストアし、その日に取得されたREDOログを適用できるという条件が揃っている必要があります。 そのため、1日のREDOログ書き込みサイズを常に監視し、REDOログのグループ数を、更新処理の増大に伴って追加していく必要があります。</p>
<div class="trBoxC"><div class="trBoxWidth" style="width:590px;">
<div class="box cmsBoxNoborder cmsBox">
<p>計画的なシャットダウンが許容されているかどうかによって、バックアップ取得の種類が異なります。 代表的なパターンを考えてみます。</p>
<ul>
<li>毎日1回シャットダウンして全データベースのバックアップ取得をするための晴間をとることができる</li>
<li>24時間365日稼働が原則の運用を要求されている</li>
</ul>
<br clear="all"><span></span></div>
</div></div>
<p>　シャットダウンできる環境では、仝データベースのバックアップを取得することができます。 最悪の場合でも、全データベースのバックアップを戻せばその時点のデータベースの状態に戻すことができるという意味で、貴重なバックアップです。</p>
<p>　24時間365日稼働が原則の運用条件では、オンラインバックアップしか取得できません。 どの物理ディスクが障害を起こした場合でも回復できるように、周期を決めてデータファイルのバックアップ計画を立てていきます。 ただし、バックアップ取得の頻度は異なっていてもよく、頻繁に更新されるデータファイルは頻繁にバックアップを取得しておき、回復処理の時間を短縮できるようにします （そもそも読み書きの頻度が高いファイルは壊れやすいということもあります）。</p>
<p>　また、オンラインバックアップ取得計画を立てる際、新規に追加されたデータファイルのバックアップ取得を計画に入れ忘れることが多いので、注意してください。 回復処理時間の短縮を図るのであれば、増分バックアップを考慮に入れ、Oracle製品であれば、リカバリマネージャを使ったバックアップ取得、リカバリ手順を考慮してもよいと思います。</p>
<p>　バックアップをとるデータファイルの数が多い、オンラインによるバックアップ取得を行う必要がある、増分バックアップを考えている、確保しておくべき世代を管理する必要がある、など複雑な手順が増えてくるに従って、手作業ですべてを管理するのは困難になってきます。 大規模で、クリティカルな条件の基でデータベースを運用する場合、上手に管理ツールを使用することをお勧めします。</p>
<h4>ユーザーデータベースのハードウェア要件</h4>
<p>　費用との関連で検討すべきですが、次のようなソリューションも視野に入れてバックアップ／リカバリ運用を検討する必要があります。</p>
<div class="cmsList">
<ul>
<li>ハードウェアRAIDの構成</li>
<li>各DBMSに対応したバックアップリカバリツールの利用</li>
<li>データベースのレプリケーション</li>
<li>高速、大容量のストレージ装置の利用
<ul>
<li>SAN（StorageAreaNetwork）</li>
<li>NAS（NetworkattachedStorage）</li>
</ul>
</li>
</ul>
</div>
<p><strong>●SANとNAS</strong></p>
<p>　それまでローカルに管理されていたストレージは、他のサーバの空き領域が大きくても利用できない、サーバ障害時には、そのサーバに接続しているストレージにはアクセスできないというデメリットがありました。</p>
<p>　SANは、ファイバーチャネルを使って、ストレージ専用のネットワークを構築し、ディスクやテープといった装置を接続します。 インターネットの普及によって、急増するデータを統合的に管理し、かつシステムパフォーマンスを向上させるためには、SANの技術は欠かせないものになっています。</p>
<p>　SANをバックアップ処理のための手段として考えたとき、バックアップ用のデータがLAN上に流れないため、処理を高速に行うことができます。 また、バックアップ処理を行うためのCPUに負荷をかけないようにするため、サーバレスバックアップに対応する製品化も進んでいます。 高信頼性、高速性が求められるバックアップ環境に通したソリューションといえます。</p>
<p>　NASは、ワークステーションやサーバから、TCP／IPネットワーク経由でNFS（Network File System）などを使ってファイルヘアクセスしているので、ファイル共有が簡単にできます。 また、ネットワーク経由でUNIXやWindows間でのデータ共有も可能なため、多くのユーザーがデータを共有できる点がメリットです。 ただし、TCP／IPプロトコルを使ってデータ転送を行うため、ファイバチャネルプロトコルに比べると、送受信時にソフトウェアの処理が多くなります。このため、大きなデータを送受信する場合、サーバのCPU負荷が大きくなります。この点で、データベースにはNASの機能は向かないといわれています。</p>
<p>　費用の面だけで見るといろいろな機能を取り入れるのに制約がかかってしまいますが、データが適切な速度でアクセスでき、信頼性の高いシステムがあって始めてシステムとして利用できるわけですから、必要な投資は惜しまない方がよいでしょう。</p>


</body></html>


